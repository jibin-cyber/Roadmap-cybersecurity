Introduction to Python:
Python is a programming language that lets you work quickly
and integrate systems more effectively.
Python's developers typically prioritise readability over performance, Python is meant to be an easily readable language. Its formatting is visually uncluttered and often uses English keywords where other languages use punctuation. Unlike many other languages, it does not use curly brackets to delimit blocks, and semicolons after statements are allowed but rarely used.
Python was made to easily read code where even children can learn python, it is 1 of the easiest programming language

Variables in Python :
x=2
x+2
4
x=9
x+2
11
Now I will put value for you
y=4
x+y
13
_+y - underscroll is last output, in this case it is 13
17- answer
Lets start with a name
name= ('jibin')
name+'rocks'
'jibinrocks'
Fetching the letters 
fore.g 
name= ('jibin') 01234
name [0]
j- answer
Now we can use -any number, it will show the number from right side to self, in this case it is 'n'
we can also know the length of a text
e.g: myname= ('jibinraj')
len(myname)- len is the command
8- answer

List in python :
when we use list in python we should you use square brackets to put values in a variable.
nums=[20,30,40,50]
just input nums and then enter
[20,30,40,50]
we can use index numbers also - Indexing in Python is the process of accessing individual elements within a sequence (like a string, list, or tuple) using their position, or "index," within that sequence.
nums[0]
20
nums [2:]
[40, 50]
nums [-1]
50
lets do strings-  In Python, a string is a sequence of characters. For example, "hello" is a string containing a sequence of characters 'h' , 'e' , 'l' , 'l' , and 'o' .
names =['jibin,vardhan,arjun']
names
['jibin,vardhan,arjun']
now lets put some values-
values=[9.5,'jibin',40]
mil= [names, values]
mil
[['jibin,vardhan,arjun'], [9.5, 'jibin', 40]]

Python provides a rich set of built-in functions and methods specifically designed for manipulating lists. These can be categorized as follows:
List Methods-
Let's look at different list methods in Python:
while using list function we need to use parentheses brackets

append(): Adds an element to the end of the list.
copy(): Returns a shallow copy of the list.
clear(): Removes all elements from the list.
count(): Returns the number of times a specified element appears in the list.
extend(): Adds elements from another list to the end of the current list.
index(): Returns the index of the first occurrence of a specified element.
insert(): Inserts an element at a specified position.
pop(): Removes and returns the element at the specified position (or the last element if no index is specified).
remove(): Removes the first occurrence of a specified element.
reverse(): Reverses the order of the elements in the list.
sort(): Sorts the list in ascending order (by default).

input- nums[20, 30, 40, 50]
nums.append(60)
nums
[20, 30, 40, 50, 60]
nums.insert(2,35)
nums
[20, 30, 35, 40, 50, 60]
nums.remove(35)
nums
[20, 30, 40, 50, 60]
nums.pop(2)
40
nums.pop()
60
del nums[2:]
nums
[20, 30]
nums.extend([70,80,90,100])
nums
[20, 30, 70, 80, 90, 100]
min(nums)
20
max(nums)
100
nums.sort()
nums
[20, 30, 70, 80, 90, 100]

Tuple and Set in Python :
Set in Python-
A Set is an unordered collection of unique elements. Sets are primarily used when membership tests and eliminating duplicate values are needed.

Mutable: Elements can be added or removed.
Unordered: Does not maintain the order of elements.
Unique Elements: Duplicate values are automatically removed.
Heterogeneous: Can store different data types.
Tuple in Python-
A Tuple is an ordered, immutable collection of elements. Tuples are often used when data should not be modified after creation. In Tuple we use parenthesus or round brackets

Immutable: Once created, elements cannot be modified.
Ordered: Maintains the order of elements.
Allows Duplicates: Can contain duplicate values.
Heterogeneous: Can store different data types.

Python Dictionary :
Python dictionary is a data structure that stores the value in key: value pairs. Values in a dictionary can be of any data type and can be duplicated, whereas keys can't be repeated and must be immutable.

Keys are case sensitive which means same name but different cases of Key will be treated distinctly.
Keys must be immutable which means keys can be strings, numbers or tuples but not lists.
Duplicate keys are not allowed and any duplicate key will overwrite the previous value.
Internally uses hashing. Hence, operations like search, insert, delete can be performed in Constant Time.

Dictionary can be created by placing a sequence of elements within curly {} braces.
Input- d1 = {1: 'Geeks', 2: 'For', 3: 'Geeks'}
print(d1)
output- {1: 'Geeks', 2: 'For', 3: 'Geeks'}

# create dictionary using dict() constructor
Input- d2 = dict(a = "Geeks", b = "for", c = "Geeks")
print(d2)
output- {'a': 'Geeks', 'b': 'for', 'c': 'Geeks'}

Accessing Dictionary Items-
We can access a value from a dictionary by using the key within square brackets or get() method.
d = { "name": "Prajjwal", 1: "Python", (1, 2): [1,2,4] }

# Access using key
print(d["name"])

# Access using get()
print(d.get("name"))
Output
Prajjwal
Prajjwal

Adding and Updating Dictionary Items-
input-d = {1: 'Geeks', 2: 'For', 3: 'Geeks'}

# Adding a new key-value pair
d["age"] = 22

# Updating an existing value
d[1] = "Python dict"

print(d)
output-
{1: 'Python dict', 2: 'For', 3: 'Geeks', 'age': 22}

Removing Dictionary Items-
del: Removes an item by key.
pop(): Removes an item by key and returns its value.
clear(): Empties the dictionary.
popitem(): Removes and returns the last key-value pair.

d = {1: 'Geeks', 2: 'For', 3: 'Geeks', 'age':22}

# Using del to remove an item
del d["age"]
print(d)

# Using pop() to remove an item and return the value
val = d.pop(1)
print(val)

# Using popitem to removes and returns
# the last key-value pair.
key, val = d.popitem()
print(f"Key: {key}, Value: {val}")

# Clear all items from the dictionary
d.clear()
print(d)
output-
{1: 'Geeks', 2: 'For', 3: 'Geeks'}
Geeks
Key: 3, Value: Geeks
{}

More on Variables in Python :
In Python, variables are names that refer to objects in memory. The "address" of a variable, in the context of Python, refers to the memory address where the object that the variable points to is stored. This is not the same as a C-style variable address, which directly refers to a specific memory location holding the variable's value. In Python, variables are more like labels or tags for objects. 
To find the memory address of the object a variable refers to, you use the built-in id() function. This function returns a unique identifier for an object, which is effectively its memory address during the object's lifetime.

id(num)
140707540399144
name= 'jibin'
id(num)
140707540399144
id(name)
1243011247408

Now If we want to create multiple variables and it has same data or value, it will have same id or address for memory efficient
a= 10
b= a
a
10
b
10
id(a)
140707540399304
id(b)
140707540399304
k=10
id(10)
140707540399304
id(k)
140707540399304
Its basically tagging the value 10, if only if you change the value to some other number, it will change your id or address
If any data or value is not tagged by any variable, then it is garbage collected

Data Types in Python:
Data types in Python are a way to classify data items. They represent the kind of value, which determines what operations can be performed on that data. Since everything is an object in Python programming, Python data types are classes and variables are instances (objects) of these classes.
Python Data Types-
1. text
2. None
3. Numeric- Integer, float, complex
4. sequence- list, tuple, string, range
5. mapping- dictionary
6. set
7. boolean

Example	                                  Data Type	
x = "Hello World"	                        str	
x = 20	                                    int	
x = 20.5	                                float	
x = 1j	                                    complex	
x = ["apple", "banana", "cherry"]	        list	
x = ("apple", "banana", "cherry")	        tuple	
x = range(6)	                            range	
x = {"name" : "John", "age" : 36}	        dict	
x = {"apple", "banana", "cherry"}	        set	
x = frozenset({"apple", "banana", "cherry"})frozenset	
x = True	                                bool	
x = b"Hello"	                            bytes	
x = bytearray(5)	                        bytearray	
x = memoryview(bytes(5))	                memoryview	
x = None	                                NoneType	

Operators in Python :
Arithmetic Operators-
| Operator | Meaning             | Example       |
| -------- | ------------------- | ------------- |
| `+`      | Addition            | `5 + 2 â†’ 7`   |
| `-`      | Subtraction         | `5 - 2 â†’ 3`   |
| `*`      | Multiplication      | `5 * 2 â†’ 10`  |
| `/`      | Division            | `5 / 2 â†’ 2.5` |
| `//`     | Floor division      | `5 // 2 â†’ 2`  |
| `%`      | Modulus (remainder) | `5 % 2 â†’ 1`   |
| `**`     | Exponent            | `2 ** 3 â†’ 8`  |

Assignment Operators-
| Operator | Example  | Meaning     |
| -------- | -------- | ----------- |
| `=`      | `x = 5`  | Assign      |
| `+=`     | `x += 2` | `x = x + 2` |
| `-=`     | `x -= 2` | `x = x - 2` |
| `*=`     | `x *= 2` | `x = x * 2` |
| `/=`     | `x /= 2` | `x = x / 2` |
a,b=5,6
a
5
b
6
unary operator-
n=7
n
7
-n
-7
n=-n
n
-7
Comparison (Relational) Operators-
Used to compare two values. Result is True or False.
| Operator | Meaning               |
| -------- | --------------------- |
| `==`     | Equal to              |
| `!=`     | Not equal to          |
| `>`      | Greater than          |
| `<`      | Less than             |
| `>=`     | Greater than or equal |
| `<=`     | Less than or equal    |

Logical Operators-
Used to combine conditions.
| Operator | Meaning                 |
| -------- | ----------------------- |
| `and`    | True if both are True   |
| `or`     | True if any one is True |
| `not`    | Reverse the result      |

a=5
b=4
a<8 and b<5
True
a<8 and b<2
False
In 'and' if we 1 condition is true and other is false, the the answer will be false because and is used for 2 same conditions
now lets do 'or' operator -
a<8 or b<2
True
In 'or' even if 1 condition is true, then the output will be true.
now lets do 'not' operator-
The not keyword in Python is a logical operator used to obtain the negation or opposite Boolean value of an operand.
 Basic example of not operator with True. Here, we used "not" operator to change the true value to false which is the negation of True.
 a = True
print(not a)
output
False

Number System Conversion in Python :
In Python, number systems mainly refer to how numbers are represented and converted between different bases.

Python commonly works with these four number systems-
1ï¸âƒ£ Decimal (Base 10)
Digits: 0â€“9

Default number system in Python
a = 25
print(a)

2ï¸âƒ£ Binary (Base 2)
Digits: 0, 1

Prefix: 0b or 0B

b = 0b11001
print(b)        # 25

print(bin(25))  # '0b11001'

3ï¸âƒ£ Octal (Base 8)
Digits: 0â€“7

Prefix: 0o or 0O

c = 0o31
print(c)        # 25

Convert decimal â†’ octal-
print(oct(25))  # '0o31'

4ï¸âƒ£ Hexadecimal (Base 16)
Digits: 0â€“9 and Aâ€“F

Prefix: 0x or 0X

d = 0x19
print(d)        # 25
Convert decimal â†’ hexadecimal-
print(hex(25))  # '0x19'

ðŸ” Converting Between Number Systems
Use int(value, base) to convert from any base to decimal:
print(int("11001", 2))   # Binary â†’ Decimal
print(int("31", 8))      # Octal â†’ Decimal
print(int("19", 16))     # Hex â†’ Decimal

Python BitWise Operators :
compliment operator-
Inverts all bits (twoâ€™s complement effect).
print(~12)   # -13

12  â†’  0000...1100
~12 â†’  1111...0011  â†’ -13
Now we will understand how to come to the value of -13
First we will consider bin (12)
which is 1100, how?
2|12 - 0
2|6 - 0
2|3 - 1
 |1 
 In this we will take the remainder from below which is 1100, so bin(12) is 1100
 but there is a problem in 4 bits 1100, 4-bit signed numbers cannot represent âˆ’13, because 4 bit signed range âˆ’8  to  +7
 CPUs usually use 8 / 16 / 32 / 64 bits, not 4
 so thats why we will use 8 bits so now 
 bin(12)= 00001100
 always add 0,s before the value
 1's comp - ~12 = 11110011 
 2's comp = 1's comp+1
 ans= 11110011
     +       1
     11110010
Now we need to find -13, so we need check the comp of 13 aswell, for that we need to check bin of 13 aswell
bin(13)
2|13
2|6 - 1
2|3 - 0
2|1 - 1
bin(13)= 00001101
1's comp = 11110010
2's comp = 11110011
so here we go the ~12 = -13 hence proved

 Where compliment is used-

CPUs (Intel, AMD, ARM)

Programming languages (C, C++, Python internally, Java)

Calculators

Embedded systems

Without complement â†’ negative numbers would not exist in computers.

And& and or | operators-
e.g- 12 & 13
we will do bin for both 12 & 13
12= 00001100
13= 00001101
ans= 00001100- so answer is 12

Now 12 or 13, 12|13
12= 00001100
13= 00001101
ans= 00001101- so answer is 13
If comparing even one times 1 comes, value will be 1

XOR-
we will use ^ cap symbol for XOR
12^13= 1
1st we will take bin of both 12 and 13
12= 00001100
13= 00001101
ans=00000001

25^30 = 7
25= 00011001
30= 00011110
ans=00000111
         421= 7

Left shift <<:
In left shift we are gaining
for e.g 10<<2 = 40, 10 bytes 2 bits
First we will take bin (10)= 1010
so we will add 2 0's after 1010
ans= 101000
    32168421 = 32+8= 40

Right shift >>:
In right shift we are losing
10>>2 = 2
1010= 10= 2












